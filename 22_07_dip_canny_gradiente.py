# -*- coding: utf-8 -*-
"""22_07_DIP_Canny_Gradiente.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dR4sKF8jnXoHwlpOVQQS4IOA4I00mVKB

# Progetto Gradient Linking
Partendo dal Canny sostituiamo l'ultima fase con il _Gradient Linking_
"""

import numpy as np
import cv2
from matplotlib import pyplot as plt

data_path = ""

"""## Utility per caricamento immagini di test"""

import os


def show_image(image, title):
    if(len(image.shape)==2):
        plt.imshow(image, cmap = 'gray', interpolation = 'bicubic', vmin=0, vmax=255)
    else:
        plt.imshow(image, interpolation = 'bicubic', vmin=0, vmax=255)

    plt.title(title)
    plt.xticks([]), plt.yticks([])  # to hide tick values on X and Y axis
    plt.show()

"""## Algoritmi per Canny

### Blur
"""

# Blur

"""### Sobel
Calcola fase e modulo del gradiente
"""

def get_gradient_mag_phase(image):
    # Soblel kernels
    Sx = np.asarray([[-1, 0, 1 ],[-2, 0, 2],[-1, 0, 1]], dtype=float)
    Sy = np.asarray([[1, 2, 1 ],[0, 0, 0,],[-1, -2, -1]], dtype=float)

    Gx = cv2.filter2D(image,cv2.CV_32F,Sx)
    Gy = cv2.filter2D(image,cv2.CV_32F,Sy)
    # Magnitude
    G=np.sqrt(np.square(Gx)+np.square(Gy))
    # Phase
    Theta = np.degrees(np.arctan2(Gy,Gx)).astype(int)
    return G, Theta

"""### Non Maxima Suppression
Elimina edge
"""

# Verisone prof
def non_maxima_suppression(G, Theta):
    angle = np.where(Theta < 0, Theta, Theta+180)
    ## Here I usse lambda functions but you can do in many other ways
    angle = np.vectorize(lambda x: ((int((x+22.5)/45.))*45)%180)(angle)
    edge_candidates=np.zeros(G.shape, dtype=np.uint8)

    for i in range(1,G.shape[0]-1):
        for j in range(1,G.shape[1]-1):
            if angle[i,j] == 0:
                if np.max([G[i,j-1],G[i,j],G[i,j+1]]) == G[i,j]:
                    edge_candidates[i,j] = 1
            elif angle[i,j] == 45:
                if np.max([G[i+1,j-1],G[i,j],G[i-1,j+1]]) == G[i,j]:
                    edge_candidates[i,j] = 1
            elif angle[i,j] == 90:
                if np.max([G[i-1,j],G[i,j],G[i+1,j]]) == G[i,j]:
                    edge_candidates[i,j] = 1
            elif angle[i,j] == 135:
                if np.max([G[i-1,j-1],G[i,j],G[i+1,j+1]]) == G[i,j]:
                    edge_candidates[i,j] = 1

    return edge_candidates

"""NMS in 4 direzioni"""

"""##Canny Edge"""

# Canny Edge
def canny_edge(image):
    #1 Gaussian low pass - remove noise
    blurred = cv2.GaussianBlur(image, (7,7), 0)
    # result=equalizationImgBN(result) #equalizzare l'immagine blur a volte aiuta ad ottenere risultati migliori come nel caso di cityscapes.png
    #2 Gradient estimation
    G, Theta = get_gradient_mag_phase(blurred)
    #3 Non maxima suppresion
    result = non_maxima_suppression(G, Theta)
    return result, Theta, G

"""## Gradient linking

###Discretizzazione Theta
"""

def descrete_theta(theta):
  theta_discreto = np.where(theta < 0, theta + 180, theta)
  theta_discreto = np.vectorize(lambda x: ((int((x+11.25)/22.5))*22.5)%180)(theta_discreto)
  return theta_discreto

# Discretizza gli angoli a 0, 30, 45, 60, 90, 120, 135, 150 gradi
def discretize_angle(x):
    if 0 <= x < 15 or 165 <= x <= 180:
        return 0
    elif 15 <= x < 37.5:
        return 30
    elif 37.5 <= x < 52.5:
        return 45
    elif 52.5 <= x < 75:
        return 60
    elif 75 <= x < 105:
        return 90
    elif 105 <= x < 127.5:
        return 120
    elif 127.5 <= x < 142.5:
        return 135
    elif 142.5 <= x < 165:
        return 150

"""###Estrazione candidati"""

def candidate(x, y, tetha):
  candidati=[(x,y)]
  match tetha:
    case 0:
      candidati = [(x-2, y),(x-1, y),(x, y),(x+1, y),(x+2, y)] # colonna centrale
      candidati.extend([(x-2, y+1),(x-1, y+1),(x, y+1),(x+1, y+1),(x+2, y+1)]) # colonna dx
      candidati.extend([(x-2, y-1),(x-1, y-1),(x, y-1),(x+1, y-1),(x+2, y-1)]) # colonna sx

    case 45:
      candidati=[(x-2, y-2),(x-1, y-1),(x, y),(x+1, y+1),(x+2, y+2)] # diagonale centrale
      candidati.extend([(x-2, y-1),(x-1, y),(x, y+1),(x+1, y+2)]) # diagonale sup
      candidati.extend([(x-1, y-2),(x, y-1),(x+1, y),(x+2, y+1)]) # diagonale inf

    case 90:
      candidati=[(x, y-2),(x, y-1),(x, y),(x, y+1),(x, y+2)] # Riga centrale
      candidati.extend([(x-1, y-2),(x-1, y-1),(x-1, y),(x-1, y+1),(x-1, y+2)]) # Riga orizzontale sup
      candidati.extend([(x+1, y-2),(x+1, y-1),(x+1, y),(x+1, y+1),(x+1, y+2)]) # Riga orizzontale inf

    case 135:
      candidati=[(x-2, y+2),(x-1, y+1),(x, y),(x+1, y-1),(x+2, y-2)] # diagonale centrale
      candidati.extend([(x-2, y+1),(x-1, y),(x, y-1),(x+1, y-2)]) # diagonale sup
      candidati.extend([(x-1, y+2),(x, y+1),(x+1, y),(x+2, y-1)]) # diagonale inf

  return candidati

def candidate_8(i, j, tetha):
  candidati=[[i,j]]
  if tetha==0:
    candidati = [[i-1, j],[i-2, j],[i+1, j],[i+2, j]] # colonna centrale
    candidati.extend([[i-1, j-1],[i-2, j-1],[i+1, j-1],[i+2, j-1]]) # colonna dx
    candidati.extend([[i-1, j+1],[i-2, j+1],[i+1, j+1],[i+2, j+1]]) # colonna sx

  elif tetha== 30:
    candidati=[[i-1,j-1], [i-2,j-1], [i+1,j+1], [i+2, j+1], [i-1, j],[i+1, j]]
    # candidati.extend( [i,max(j-1, 0)], [max(i-1,0),max(j-2,0)], [max(i-2,0),max(j-2,0)], [min(i+1,h),max(j-1,0)], [min(i+2, h),j])
    # candidati.extend([i,min(j+1, l)], [max(i-1,0),min(j+1,l)], [max(i-2,0),j], [min(i+1, h),min(j+2,l)], [min(i+2, h),min(j+2,l)]

  elif tetha== 45:
    candidati=[[i-2, j-2],[i-1, j-1],[i, j],[i+1, j+1],[i+2, j+2]] # diagonale centrale
    candidati.extend([[i-2, j-1],[i-1, j],[i, j+1],[i+1, j+2]]) # diagonale sup
    candidati.extend([[i-1, j-2],[i, j-1],[i+1, j],[i+2, j+1]]) # diagonale inf

  elif tetha == 60:
    candidati=[[i-1,j-1], [i-1,j-2], [i+1,j+1], [i+1,j+2], [i,j-1], [i,j+1]]
    #  [max(i-1,0),j], [max(i-2,0),max(j-1,0)], [max(i-2,0),max(j-2,0)], [max(i-1,0),min(j+1,l)], [i,min(j+2,l)],
    #  [i,max(j-2, 0)], [min(i+1,h),j], [min(i+1, h),max(j-1,0)], [min(i+2, h),min(j+1,l)],[min(i+2, h),min(j+2,l)]


  elif tetha== 90:
    candidati=[[i, j-2],[i, j-1],[i, j],[i, j+1],[i, j+2]] # Riga centrale
    candidati.extend([[i-1, j-2],[i-1, j-1],[i-1, j],[i-1, j+1],[i-1, j+2]]) # Riga orizzontale sup
    candidati.extend([[i+1, j-2],[i+1, j-1],[i+1, j],[i+1, j+1],[i+1, j+2]]) # Riga orizzontale inf

  elif tetha== 120:
    candidati=[[i-1,j+1], [i-1,j+2], [i+1,j-1], [i+1,j-2], [i,j-1], [i,j+1]]
    #  [max(i-1,0),j],[max(i-2,0),min(j+1,l)], [max(i-2,0),min(j+2,l)],[max(i-1,0),max(j-1, 0)], [i,max(j-2,0)],
    #  [i,min(j+2,l)], [min(i+1,h),j], [min(i+1,h),min(j+1,l)],[min(i+2,h),max(j-1,0)],[min(i+2,h),max(j-2,0)]

  elif tetha== 135:
    candidati=[[i-2, j+2],[i-1, j+1],[i, j],[i+1, j-1],[i+2, j-2]] # diagonale centrale
    candidati.extend([[i-2, j+1],[i-1, j],[i, j-1],[i+1, j-2]]) # diagonale sup
    candidati.extend([[i-1, j+2],[i, j+1],[i+1, j],[i+2, j-1]]) # diagonale inf

  elif tetha == 150:
    candidati=[[i-1,j+1], [i-2,j+1], [i+1,j-1], [i+2,j-1], [i-1, j],[i+1, j]]
    #  [i,max(j-1, 0)], [max(i-1,0),max(j-1,0)], [max(i-2,0),j], [max(i-2,0),min(j+2,l)], [max(i-1,0),min(j+2,l)],
    #  [i,min(j+1, 0)], [min(i+1,h),max(j-2,0)], [min(i+2, h),max(j-2,0)],[min(i+1, h),min(j+1,l)], [min(i+2, h),j]
  return candidati

# il filtro elimina i candidati che eccedono le dimensioni dell'immagine
def filtro_candidati(candidati, h, l):
    array = np.array(candidati)

    # Elimina gli elementi con x o y < 0
    array = array[(array[:,0] >= 0) & (array[:,1] >= 0)]

    # Elimina gli elementi con x > h
    array = array[array[:,0] <= h]

    # Elimina gli elementi con y > l
    array = array[array[:,1] <= l]

    return array

"""###Filtro candidati non edge"""

def candidati_edge_filtro(candidati, edge_map):
  # elimina i candidati che non sono edge
  bem_candidati = [edge_map[x, y] for (x,y) in candidati]
  candidati= [(x,y) for k, ((x,y), edge) in enumerate(zip(candidati,bem_candidati)) if edge==1]
  return candidati

"""### Gradient linking: 4 direzioni"""

#Gradient
def gradient_linking(bem, theta, interval):
  # discretizzo tetha
  theta_discreto = descrete_theta(theta)

  # imposto la label_map
  label_map=np.zeros(bem.shape)

  l=bem.shape[1]-1
  h=bem.shape[0]-1
  label_counter=1

  for i in range(0, h):
    for j in range(0, l):

      # se p è edge e in label map non è ancora controllato
      if bem[i,j]==1 and label_map[i,j]==0:
        candidati=candidate(i, j, theta_discreto[i,j])
        candidati=filtro_candidati(candidati, h, l)

        #valori di bem e theta dei candiadati
        #candidati= candidati_edge_filtro(candidati, bem)

        if len(candidati)>3:
          theta_candidati= [theta[x, y] for (x,y) in candidati]
          #theta_candidati_disc= [theta_discreto[ind[0], ind[1]] for ind in candidati]

          diff_theta=abs(theta_candidati-theta[i, j])
          label_candidati=[label_map[x, y] for (x,y) in candidati]

          if np.max(diff_theta)<=interval or np.max(diff_theta)>=360-interval:
            #tutti i punti hanno stessa direzione +/- 40 gradi di p
            if np.max(label_candidati) == 0:
              lab=label_counter
              label_counter=label_counter+1
            else:
              lab=np.max(label_candidati)

            label_map[i,j]=lab
            for c in candidati:
              label_map[c[0],c[1]]=lab

          elif np.min(diff_theta) >40 or np.min(diff_theta) > 320:
            #tutti i candidati hanno direzioni diverse da p
            for c in candidati:
              label_map[c[0],c[1]]=0

      elif bem[i,j]==0:
        label_map[i,j]=0


  return label_map

"""### Gradient linking: 8 direzioni


"""

#Gradient
def gradient_linking_8(bem, theta, interval):
  #theta_discreto = np.where(Theta < 0, Theta, Theta+180)
  #theta_discreto = np.vectorize(lambda x: ((int((x+11.25)/22.5))*22.5)%180)(theta_discreto)
  theta_discreto = np.where(Theta < 0, Theta + 180, Theta)
  theta_discreto = np.vectorize(discretize_angle)(theta_discreto)

  label_map=np.zeros(bem.shape)

  l=bem.shape[1]-1
  h=bem.shape[0]-1
  label_counter=1
  for i in range(0, h):
    for j in range(0, l):
      candidati=[]
      # se p è edge e in label map non è ancora controllato
      if bem[i,j]==1 and label_map[i,j]==0:

        candidati=candidate_8(i, j, theta_discreto[i,j])
        candidati=filtro_candidati(candidati, h, l)
        candidati= candidati_edge_filtro(candidati, bem)

        if len(candidati)>3:
          theta_candidati= [theta[ind[0], ind[1]] for ind in candidati]
          diff_theta=abs(theta_candidati-theta[i, j])
          label_candidati=[label_map[ind[0], ind[1]] for ind in candidati]

          if np.max(diff_theta)<=interval or np.max(diff_theta)>=360-interval:
            #tutti i punti hanno stessa direzione +/- interval gradi di p
            if np.max(label_candidati) == 0:
              lab=label_counter
              label_counter=label_counter+1
            else:
              lab=np.max(label_candidati)

            for c in candidati:
              label_map[c[0],c[1]]=lab

          elif np.min(diff_theta) >40 or np.min(diff_theta) > 320:
            #tutti i candidati hanno direzioni diverse da p
            for c in candidati:
              label_map[c[0],c[1]]=0

      elif bem[i,j]==0:
        label_map[i,j]=0

  return label_map

"""## Funzioni Accessorie

### Equalizzazione immagine
"""

def equalizationImgBN(img):
  img2=255*np.ones((img.shape), dtype=img.dtype)
  f_img = f(h(img))

  for i in range(img.shape[0]):
    for j in range(img.shape[1]):
      img2[i][j]=f_img[img[i][j]]*255

  return img2

def f(h_vet):
  f_k=np.zeros(len(h_vet))
  for k in range(0,len(h_vet)):
    f_k[k]=sum(h_vet[0:k])

  return f_k

def h(img):
  h_vet=np.zeros(256, dtype=int)

  for i in range(img.shape[0]):
    for j in range(img.shape[1]):
      h_vet[img[i][j]]+=1

  n_pixel=img.shape[0]*img.shape[1]
  h_vet=h_vet/n_pixel
  #plt.stem(h_vet, 'b')
  return h_vet

"""### Istogramma G"""

def thresholds_estimation(G):
  plt.hist(G, bins=10, edgecolor='black')
  plt.xlabel('Valori')
  plt.ylabel('Frequenza')
  plt.title('Istogramma dei valori della matrice')

  plt.show()

"""### Color label map"""

# Your color map
color_map = [
    #(255, 255, 255),  # Bianco
    (255, 0, 0),      # Rosso
    (0, 255, 0),      # Verde
    (0, 0, 255),      # Blu
    (255, 255, 0),    # Giallo
    (255, 0, 255),    # Magenta
    (0, 255, 255),    # Ciano
    (128, 0, 0),      # Marrone
    (128, 128, 0),    # Oliva
    (0, 128, 0),      # Verde scuro
    #(128, 0, 128)     # Porpora
]

# Function to map labels to colors
def label_to_color(label_image, color_map):
    height, width = label_image.shape
    color_image = np.zeros((height, width, 3), dtype=np.uint8)

    for label in np.unique(label_image):
        if label != 0:  # Ignore background label
            label_int = int(label)
            color_image[label_image == label] = color_map[label_int % len(color_map)]

    return color_image


def eval(BEM1, BEM2):
  results = {}

  results['f_score'] = Evaluation.f_score(BEM1, BEM2)
  results['mse'] = Evaluation.mse(BEM1, BEM2)
  results['epe'] = Evaluation.epe(BEM1, BEM2)
  results['accuracy'] = Evaluation.accuracy(BEM1, BEM2)
  results['jaccard'] = Evaluation.jaccard(BEM1, BEM2)

  return results

"""# Testing
Sezione di testing dell'algoritmo

##Caricamento immagine di test
La funzione

```
image_load("image_name.jpg")
```
collega il drive se necessario e carica l'immagine dalla cartella "/Colab Notebooks/DIP/Data" </br>
Se è necessario cambiare il nome della cartella "Data" si può specificare in questo modo:


```
image_load("image_name.jpg", "nome_cartella")
```
Di default carica l'immagine in bianco e nero. Per colore aggiungere terzo parametro settato su "True".
"""

# Load and Display the Image

#############################
#                           #
#     LEGGI SOPRA !!!!      #
#                           #
#############################

image = None
image = load_image("cityscapes.png")
#image = load_image("lena.png")
#image = load_image("geometria.jpg")
#image = load_image("cerchi.jpg")
show_image(image, "Input image")

"""##Blur ed equalization
Questo blocco si usa solo per vedere il risultato delle "funzioni accessorie" e del blur che però è già incluso in Canny.

NON USARE PER PASSARE INPUT AD ALGORITMO A/B
"""

blurred=cv2.GaussianBlur(image,(7,7),0)
eq_blur=equalizationImgBN(blurred)
show_image(blurred, "Blurred image")
show_image(eq_blur, "Equalized blurred image")

G, theta = get_gradient_mag_phase(blurred)
thresholds_estimation(G)

"""## Algoritmo A
1. Canny
2. Threshold G > 70
3. Gradient Linking (4 direzioni)

- (22/07/24) Prima versione
- (26/07/24) Threshold G spostata da 110 a 70; Pulizia codice
"""

edge_map, Theta, G = canny_edge(image)
show_image(255*edge_map, "Edges Candidati")

# 60-70 sembra essere una soglia migliore
map_th=np.where(G>70, edge_map, 0)
show_image(255*map_th, "Edges con threshold")

label_map=gradient_linking(map_th, Theta, 35)

print("numero label: ", np.max(label_map))
print("numero pixel con label: ", np.count_nonzero(label_map))

color_image = label_to_color(label_map, color_map)
show_image(color_image, "label")

"""## Algoritmo B
1. Canny
2. Threshold G > 110
3. Gradient Linking (8 direzioni)

- (24/07/24) Prima versione
- (27/07/24) Pulizia codice
"""

edge_map, Theta, G = canny_edge(image)
show_image(255*edge_map, "Edges Candidati")

#threshold di G vista con istogramma (metodo in sezione "funzioni utili")
edge_map=np.where(G>70, edge_map, 0)
show_image(255*edge_map, "Edges con threshold")

"""Gradiente in 8 direzioni:

  [0, 30, 45, 60, 90, 120, 135, 150]
"""

label_map_8=gradient_linking_8(edge_map, Theta, 13) #provare con 15-18-20

print("numero label: ", np.max(label_map_8))
print("numero pixel con label: ", np.count_nonzero(label_map_8))

color_image = label_to_color(label_map_8, color_map)
show_image(color_image, "label")